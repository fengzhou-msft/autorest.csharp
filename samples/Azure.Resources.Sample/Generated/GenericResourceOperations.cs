// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core.Pipeline;
using Azure.ResourceManager.Core;

namespace Azure.ResourceManager.Resources
{
    /// <summary> A class representing the operations that can be performed over a specific GenericResource. </summary>
    public partial class GenericResourceOperations : ResourceOperationsBase<ResourceGroupResourceIdentifier, GenericResource>
    {
        private readonly ClientDiagnostics _clientDiagnostics;
        private readonly HttpPipeline _pipeline;
        internal ResourcesRestOperations RestClient { get; }

        /// <summary> Initializes a new instance of the <see cref="GenericResourceOperations"/> class for mocking. </summary>
        protected GenericResourceOperations()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="GenericResourceOperations"/> class. </summary>
        /// <param name="options"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        protected internal GenericResourceOperations(ResourceOperationsBase options, ResourceGroupResourceIdentifier id) : base(options, id)
        {
            _clientDiagnostics = new ClientDiagnostics(ClientOptions);
            _pipeline = Pipeline;
            RestClient = new ResourcesRestOperations(_clientDiagnostics, _pipeline, Id.SubscriptionId, BaseUri);
        }

        public static readonly ResourceType ResourceType = "resources";
        protected override ResourceType ValidResourceType => ResourceType;

        /// <inheritdoc />
        public async override Task<Response<GenericResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.Get");
            scope.Start();
            try
            {
                var response = await RestClient.GetAsync(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                return Response.FromValue(new GenericResource(this, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <inheritdoc />
        public override Response<GenericResource> Get(CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.Get");
            scope.Start();
            try
            {
                var response = RestClient.Get(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken);
                return Response.FromValue(new GenericResource(this, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a resource. </summary>
        /// <param name="apiVersion"> The API version to use for the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Response<GenericResource>> GetAsync(string apiVersion, CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.Get");
            scope.Start();
            try
            {
                var response = await RestClient.GetAsync(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, apiVersion, cancellationToken).ConfigureAwait(false);
                return Response.FromValue(new GenericResource(this, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a resource. </summary>
        /// <param name="apiVersion"> The API version to use for the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Response<GenericResource> Get(string apiVersion, CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.Get");
            scope.Start();
            try
            {
                var response = RestClient.Get(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, apiVersion, cancellationToken);
                return Response.FromValue(new GenericResource(this, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists all available geo-locations. </summary>
        /// <param name="cancellationToken"> A token to allow the caller to cancel the call to the service. The default value is <see cref="P: System.Threading.CancellationToken.None" />. </param>
        /// <returns> A collection of location that may take multiple service requests to iterate over. </returns>
        public async Task<IEnumerable<LocationData>> ListAvailableLocationsAsync(CancellationToken cancellationToken = default)
        {
            return await ListAvailableLocationsAsync(ResourceType, cancellationToken).ConfigureAwait(false);
        }

        /// <summary> Lists all available geo-locations. </summary>
        /// <param name="cancellationToken"> A token to allow the caller to cancel the call to the service. The default value is <see cref="P: System.Threading.CancellationToken.None" />. </param>
        /// <returns> A collection of location that may take multiple service requests to iterate over. </returns>
        public IEnumerable<LocationData> ListAvailableLocations(CancellationToken cancellationToken = default)
        {
            return ListAvailableLocations(ResourceType, cancellationToken);
        }

        /// <summary> Deletes a resource. </summary>
        /// <param name="apiVersion"> The API version to use for the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="apiVersion"/> is null. </exception>
        public async Task<Response> DeleteAsync(string apiVersion, CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.Delete");
            scope.Start();
            try
            {
                var operation = await StartDeleteAsync(apiVersion, cancellationToken).ConfigureAwait(false);
                return await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a resource. </summary>
        /// <param name="apiVersion"> The API version to use for the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="apiVersion"/> is null. </exception>
        public Response Delete(string apiVersion, CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.Delete");
            scope.Start();
            try
            {
                var operation = StartDelete(apiVersion, cancellationToken);
                return operation.WaitForCompletion(cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a resource. </summary>
        /// <param name="apiVersion"> The API version to use for the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="apiVersion"/> is null. </exception>
        public async Task<Azure.Operation> StartDeleteAsync(string apiVersion, CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.StartDelete");
            scope.Start();
            try
            {
                var response = await RestClient.DeleteAsync(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, apiVersion, cancellationToken).ConfigureAwait(false);
                return new ResourcesDeleteOperation(_clientDiagnostics, _pipeline, RestClient.CreateDeleteRequest(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, apiVersion).Request, response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a resource. </summary>
        /// <param name="apiVersion"> The API version to use for the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="apiVersion"/> is null. </exception>
        public Azure.Operation StartDelete(string apiVersion, CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.StartDelete");
            scope.Start();
            try
            {
                var response = RestClient.Delete(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, apiVersion, cancellationToken);
                return new ResourcesDeleteOperation(_clientDiagnostics, _pipeline, RestClient.CreateDeleteRequest(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, apiVersion).Request, response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <inheritdoc />
        public async Task<Response<GenericResource>> AddTagAsync(string key, string value, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.AddTag");
            scope.Start();
            try
            {
                var operation = await StartAddTagAsync(key, value, cancellationToken).ConfigureAwait(false);
                return await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <inheritdoc />
        public Response<GenericResource> AddTag(string key, string value, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.AddTag");
            scope.Start();
            try
            {
                var operation = StartAddTag(key, value, cancellationToken);
                return operation.WaitForCompletion(cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <inheritdoc />
        public async Task<ResourcesUpdateOperation> StartAddTagAsync(string key, string value, CancellationToken cancellationToken = default)
        {
            if (key == null)
            {
                throw new ArgumentNullException(nameof(key));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.StartAddTag");
            scope.Start();
            try
            {
                var resource = GetResource();
                var patchable = new string();
                patchable.Tags.ReplaceWith(resource.Data.Tags);
                patchable.Tags[key] = value;
                var response = await RestClient.UpdateAsync(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patchable, cancellationToken).ConfigureAwait(false);
                return new ResourcesUpdateOperation(this, _clientDiagnostics, _pipeline, RestClient.CreateUpdateRequest(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patchable).Request, response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <inheritdoc />
        public ResourcesUpdateOperation StartAddTag(string key, string value, CancellationToken cancellationToken = default)
        {
            if (key == null)
            {
                throw new ArgumentNullException(nameof(key));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.StartAddTag");
            scope.Start();
            try
            {
                var resource = GetResource();
                var patchable = new string();
                patchable.Tags.ReplaceWith(resource.Data.Tags);
                patchable.Tags[key] = value;
                var response = RestClient.Update(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patchable, cancellationToken);
                return new ResourcesUpdateOperation(this, _clientDiagnostics, _pipeline, RestClient.CreateUpdateRequest(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patchable).Request, response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <inheritdoc />
        public async Task<Response<GenericResource>> SetTagsAsync(IDictionary<string, string> tags, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.SetTags");
            scope.Start();
            try
            {
                var operation = await StartSetTagsAsync(tags, cancellationToken).ConfigureAwait(false);
                return await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <inheritdoc />
        public Response<GenericResource> SetTags(IDictionary<string, string> tags, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.SetTags");
            scope.Start();
            try
            {
                var operation = StartSetTags(tags, cancellationToken);
                return operation.WaitForCompletion(cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <inheritdoc />
        public async Task<ResourcesUpdateOperation> StartSetTagsAsync(IDictionary<string, string> tags, CancellationToken cancellationToken = default)
        {
            if (tags == null)
            {
                throw new ArgumentNullException(nameof(tags));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.StartSetTags");
            scope.Start();
            try
            {
                var patchable = new string();
                patchable.Tags.ReplaceWith(tags);
                var response = await RestClient.UpdateAsync(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patchable, cancellationToken).ConfigureAwait(false);
                return new ResourcesUpdateOperation(this, _clientDiagnostics, _pipeline, RestClient.CreateUpdateRequest(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patchable).Request, response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <inheritdoc />
        public ResourcesUpdateOperation StartSetTags(IDictionary<string, string> tags, CancellationToken cancellationToken = default)
        {
            if (tags == null)
            {
                throw new ArgumentNullException(nameof(tags));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.StartSetTags");
            scope.Start();
            try
            {
                var patchable = new string();
                patchable.Tags.ReplaceWith(tags);
                var response = RestClient.Update(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patchable, cancellationToken);
                return new ResourcesUpdateOperation(this, _clientDiagnostics, _pipeline, RestClient.CreateUpdateRequest(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patchable).Request, response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <inheritdoc />
        public async Task<Response<GenericResource>> RemoveTagAsync(string key, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.RemoveTag");
            scope.Start();
            try
            {
                var operation = await StartRemoveTagAsync(key, cancellationToken).ConfigureAwait(false);
                return await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <inheritdoc />
        public Response<GenericResource> RemoveTag(string key, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.RemoveTag");
            scope.Start();
            try
            {
                var operation = StartRemoveTag(key, cancellationToken);
                return operation.WaitForCompletion(cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <inheritdoc />
        public async Task<ResourcesUpdateOperation> StartRemoveTagAsync(string key, CancellationToken cancellationToken = default)
        {
            if (key == null)
            {
                throw new ArgumentNullException(nameof(key));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.StartRemoveTag");
            scope.Start();
            try
            {
                var resource = GetResource();
                var patchable = new string();
                patchable.Tags.ReplaceWith(resource.Data.Tags);
                patchable.Tags.Remove(key);
                var response = await RestClient.UpdateAsync(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patchable, cancellationToken).ConfigureAwait(false);
                return new ResourcesUpdateOperation(this, _clientDiagnostics, _pipeline, RestClient.CreateUpdateRequest(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patchable).Request, response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <inheritdoc />
        public ResourcesUpdateOperation StartRemoveTag(string key, CancellationToken cancellationToken = default)
        {
            if (key == null)
            {
                throw new ArgumentNullException(nameof(key));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.StartRemoveTag");
            scope.Start();
            try
            {
                var resource = GetResource();
                var patchable = new string();
                patchable.Tags.ReplaceWith(resource.Data.Tags);
                patchable.Tags.Remove(key);
                var response = RestClient.Update(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patchable, cancellationToken);
                return new ResourcesUpdateOperation(this, _clientDiagnostics, _pipeline, RestClient.CreateUpdateRequest(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patchable).Request, response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
        /// <summary> Checks whether a resource exists. </summary>
        /// <param name="apiVersion"> The API version to use for the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="apiVersion"/> is null. </exception>
        public virtual async Task<Response> CheckExistenceAsync(string apiVersion, CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.CheckExistence");
            scope.Start();
            try
            {
                return await RestClient.CheckExistenceAsync(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, apiVersion, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Checks whether a resource exists. </summary>
        /// <param name="apiVersion"> The API version to use for the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="apiVersion"/> is null. </exception>
        public virtual Response CheckExistence(string apiVersion, CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.CheckExistence");
            scope.Start();
            try
            {
                return RestClient.CheckExistence(Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, apiVersion, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Checks by ID whether a resource exists. </summary>
        /// <param name="apiVersion"> The API version to use for the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="apiVersion"/> is null. </exception>
        public virtual async Task<Response> CheckExistenceByIdAsync(string apiVersion, CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.CheckExistenceById");
            scope.Start();
            try
            {
                return await RestClient.CheckExistenceByIdAsync(Id.ResourceGroupName, apiVersion, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Checks by ID whether a resource exists. </summary>
        /// <param name="apiVersion"> The API version to use for the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="apiVersion"/> is null. </exception>
        public virtual Response CheckExistenceById(string apiVersion, CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.CheckExistenceById");
            scope.Start();
            try
            {
                return RestClient.CheckExistenceById(Id.ResourceGroupName, apiVersion, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a resource by ID. </summary>
        /// <param name="apiVersion"> The API version to use for the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="apiVersion"/> is null. </exception>
        public virtual async Task<Response<GenericResourceData>> GetByIdAsync(string apiVersion, CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.GetById");
            scope.Start();
            try
            {
                return await RestClient.GetByIdAsync(Id.ResourceGroupName, apiVersion, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a resource by ID. </summary>
        /// <param name="apiVersion"> The API version to use for the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="apiVersion"/> is null. </exception>
        public virtual Response<GenericResourceData> GetById(string apiVersion, CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.GetById");
            scope.Start();
            try
            {
                return RestClient.GetById(Id.ResourceGroupName, apiVersion, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> The resources to move must be in the same source resource group. The target resource group may be in a different subscription. When moving resources, both the source group and the target group are locked for the duration of the operation. Write and delete operations are blocked on the groups until the move completes. </summary>
        /// <param name="resources"> The IDs of the resources. </param>
        /// <param name="targetResourceGroup"> The target resource group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Response> MoveResourcesAsync(IEnumerable<string> resources = null, string targetResourceGroup = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.MoveResources");
            scope.Start();
            try
            {
                var operation = await StartMoveResourcesAsync(resources, targetResourceGroup, cancellationToken).ConfigureAwait(false);
                return await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> The resources to move must be in the same source resource group. The target resource group may be in a different subscription. When moving resources, both the source group and the target group are locked for the duration of the operation. Write and delete operations are blocked on the groups until the move completes. </summary>
        /// <param name="resources"> The IDs of the resources. </param>
        /// <param name="targetResourceGroup"> The target resource group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Response MoveResources(IEnumerable<string> resources = null, string targetResourceGroup = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.MoveResources");
            scope.Start();
            try
            {
                var operation = StartMoveResources(resources, targetResourceGroup, cancellationToken);
                return operation.WaitForCompletion(cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> The resources to move must be in the same source resource group. The target resource group may be in a different subscription. When moving resources, both the source group and the target group are locked for the duration of the operation. Write and delete operations are blocked on the groups until the move completes. </summary>
        /// <param name="resources"> The IDs of the resources. </param>
        /// <param name="targetResourceGroup"> The target resource group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Azure.Operation> StartMoveResourcesAsync(IEnumerable<string> resources = null, string targetResourceGroup = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.StartMoveResources");
            scope.Start();
            try
            {
                var response = await RestClient.MoveResourcesAsync(Id.ResourceGroupName, resources, targetResourceGroup, cancellationToken).ConfigureAwait(false);
                return new ResourcesMoveResourcesOperation(_clientDiagnostics, _pipeline, RestClient.CreateMoveResourcesRequest(Id.ResourceGroupName, resources, targetResourceGroup).Request, response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> The resources to move must be in the same source resource group. The target resource group may be in a different subscription. When moving resources, both the source group and the target group are locked for the duration of the operation. Write and delete operations are blocked on the groups until the move completes. </summary>
        /// <param name="resources"> The IDs of the resources. </param>
        /// <param name="targetResourceGroup"> The target resource group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Azure.Operation StartMoveResources(IEnumerable<string> resources = null, string targetResourceGroup = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.StartMoveResources");
            scope.Start();
            try
            {
                var response = RestClient.MoveResources(Id.ResourceGroupName, resources, targetResourceGroup, cancellationToken);
                return new ResourcesMoveResourcesOperation(_clientDiagnostics, _pipeline, RestClient.CreateMoveResourcesRequest(Id.ResourceGroupName, resources, targetResourceGroup).Request, response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This operation checks whether the specified resources can be moved to the target. The resources to move must be in the same source resource group. The target resource group may be in a different subscription. If validation succeeds, it returns HTTP response code 204 (no content). If validation fails, it returns HTTP response code 409 (Conflict) with an error message. Retrieve the URL in the Location header value to check the result of the long-running operation. </summary>
        /// <param name="resources"> The IDs of the resources. </param>
        /// <param name="targetResourceGroup"> The target resource group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Response> ValidateMoveResourcesAsync(IEnumerable<string> resources = null, string targetResourceGroup = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.ValidateMoveResources");
            scope.Start();
            try
            {
                var operation = await StartValidateMoveResourcesAsync(resources, targetResourceGroup, cancellationToken).ConfigureAwait(false);
                return await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This operation checks whether the specified resources can be moved to the target. The resources to move must be in the same source resource group. The target resource group may be in a different subscription. If validation succeeds, it returns HTTP response code 204 (no content). If validation fails, it returns HTTP response code 409 (Conflict) with an error message. Retrieve the URL in the Location header value to check the result of the long-running operation. </summary>
        /// <param name="resources"> The IDs of the resources. </param>
        /// <param name="targetResourceGroup"> The target resource group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Response ValidateMoveResources(IEnumerable<string> resources = null, string targetResourceGroup = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.ValidateMoveResources");
            scope.Start();
            try
            {
                var operation = StartValidateMoveResources(resources, targetResourceGroup, cancellationToken);
                return operation.WaitForCompletion(cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This operation checks whether the specified resources can be moved to the target. The resources to move must be in the same source resource group. The target resource group may be in a different subscription. If validation succeeds, it returns HTTP response code 204 (no content). If validation fails, it returns HTTP response code 409 (Conflict) with an error message. Retrieve the URL in the Location header value to check the result of the long-running operation. </summary>
        /// <param name="resources"> The IDs of the resources. </param>
        /// <param name="targetResourceGroup"> The target resource group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Azure.Operation> StartValidateMoveResourcesAsync(IEnumerable<string> resources = null, string targetResourceGroup = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.StartValidateMoveResources");
            scope.Start();
            try
            {
                var response = await RestClient.ValidateMoveResourcesAsync(Id.ResourceGroupName, resources, targetResourceGroup, cancellationToken).ConfigureAwait(false);
                return new ResourcesValidateMoveResourcesOperation(_clientDiagnostics, _pipeline, RestClient.CreateValidateMoveResourcesRequest(Id.ResourceGroupName, resources, targetResourceGroup).Request, response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This operation checks whether the specified resources can be moved to the target. The resources to move must be in the same source resource group. The target resource group may be in a different subscription. If validation succeeds, it returns HTTP response code 204 (no content). If validation fails, it returns HTTP response code 409 (Conflict) with an error message. Retrieve the URL in the Location header value to check the result of the long-running operation. </summary>
        /// <param name="resources"> The IDs of the resources. </param>
        /// <param name="targetResourceGroup"> The target resource group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Azure.Operation StartValidateMoveResources(IEnumerable<string> resources = null, string targetResourceGroup = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.StartValidateMoveResources");
            scope.Start();
            try
            {
                var response = RestClient.ValidateMoveResources(Id.ResourceGroupName, resources, targetResourceGroup, cancellationToken);
                return new ResourcesValidateMoveResourcesOperation(_clientDiagnostics, _pipeline, RestClient.CreateValidateMoveResourcesRequest(Id.ResourceGroupName, resources, targetResourceGroup).Request, response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a resource by ID. </summary>
        /// <param name="apiVersion"> The API version to use for the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="apiVersion"/> is null. </exception>
        public async Task<Response> DeleteByIdAsync(string apiVersion, CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.DeleteById");
            scope.Start();
            try
            {
                var operation = await StartDeleteByIdAsync(apiVersion, cancellationToken).ConfigureAwait(false);
                return await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a resource by ID. </summary>
        /// <param name="apiVersion"> The API version to use for the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="apiVersion"/> is null. </exception>
        public Response DeleteById(string apiVersion, CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.DeleteById");
            scope.Start();
            try
            {
                var operation = StartDeleteById(apiVersion, cancellationToken);
                return operation.WaitForCompletion(cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a resource by ID. </summary>
        /// <param name="apiVersion"> The API version to use for the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="apiVersion"/> is null. </exception>
        public async Task<Azure.Operation> StartDeleteByIdAsync(string apiVersion, CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.StartDeleteById");
            scope.Start();
            try
            {
                var response = await RestClient.DeleteByIdAsync(Id.ResourceGroupName, apiVersion, cancellationToken).ConfigureAwait(false);
                return new ResourcesDeleteByIdOperation(_clientDiagnostics, _pipeline, RestClient.CreateDeleteByIdRequest(Id.ResourceGroupName, apiVersion).Request, response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a resource by ID. </summary>
        /// <param name="apiVersion"> The API version to use for the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="apiVersion"/> is null. </exception>
        public Azure.Operation StartDeleteById(string apiVersion, CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.StartDeleteById");
            scope.Start();
            try
            {
                var response = RestClient.DeleteById(Id.ResourceGroupName, apiVersion, cancellationToken);
                return new ResourcesDeleteByIdOperation(_clientDiagnostics, _pipeline, RestClient.CreateDeleteByIdRequest(Id.ResourceGroupName, apiVersion).Request, response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates a resource by ID. </summary>
        /// <param name="apiVersion"> The API version to use for the operation. </param>
        /// <param name="parameters"> Update resource parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="apiVersion"/> or <paramref name="parameters"/> is null. </exception>
        public async Task<Response<GenericResource>> UpdateByIdAsync(string apiVersion, GenericResourceData parameters, CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.UpdateById");
            scope.Start();
            try
            {
                var operation = await StartUpdateByIdAsync(apiVersion, parameters, cancellationToken).ConfigureAwait(false);
                return await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates a resource by ID. </summary>
        /// <param name="apiVersion"> The API version to use for the operation. </param>
        /// <param name="parameters"> Update resource parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="apiVersion"/> or <paramref name="parameters"/> is null. </exception>
        public Response<GenericResource> UpdateById(string apiVersion, GenericResourceData parameters, CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.UpdateById");
            scope.Start();
            try
            {
                var operation = StartUpdateById(apiVersion, parameters, cancellationToken);
                return operation.WaitForCompletion(cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates a resource by ID. </summary>
        /// <param name="apiVersion"> The API version to use for the operation. </param>
        /// <param name="parameters"> Update resource parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="apiVersion"/> or <paramref name="parameters"/> is null. </exception>
        public async Task<ResourcesUpdateByIdOperation> StartUpdateByIdAsync(string apiVersion, GenericResourceData parameters, CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.StartUpdateById");
            scope.Start();
            try
            {
                var response = await RestClient.UpdateByIdAsync(Id.ResourceGroupName, apiVersion, parameters, cancellationToken).ConfigureAwait(false);
                return new ResourcesUpdateByIdOperation(this, _clientDiagnostics, _pipeline, RestClient.CreateUpdateByIdRequest(Id.ResourceGroupName, apiVersion, parameters).Request, response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates a resource by ID. </summary>
        /// <param name="apiVersion"> The API version to use for the operation. </param>
        /// <param name="parameters"> Update resource parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="apiVersion"/> or <paramref name="parameters"/> is null. </exception>
        public ResourcesUpdateByIdOperation StartUpdateById(string apiVersion, GenericResourceData parameters, CancellationToken cancellationToken = default)
        {
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope = _clientDiagnostics.CreateScope("GenericResourceOperations.StartUpdateById");
            scope.Start();
            try
            {
                var response = RestClient.UpdateById(Id.ResourceGroupName, apiVersion, parameters, cancellationToken);
                return new ResourcesUpdateByIdOperation(this, _clientDiagnostics, _pipeline, RestClient.CreateUpdateByIdRequest(Id.ResourceGroupName, apiVersion, parameters).Request, response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}
